# Беляков Глеб Б05-123

## Доказательство алгоритма
Заведем стек из сетов(при каждой операции будет взимодействовать только с первым
или еще со вторым элементом в стеке)
### Разбиение строки на символы
* Если встречаем букву, то заводим новый сет из 1
* Если встречаем  "+", то в польской записи это равносильно объединению множеств, то есть нам нужно 
просто объединить два сета(в итоге получится новый сет) (Время работа одной такой операции в худшем случае: O(size(set2)))
* Если встречаем ".", то это означает,что мы хотим конкатинировать два последних множества, то есть нужно
найти всевозможные конкатенации двух верхних сетов(Время работы: O(size(set1) * size(set2)))
* Если встречаем "*", то нам нужно получить всевозможные комбинации из последнего сета(Время работы: O(k))
### Доказательство кореектности
Данный алгоритм корректен, т.к. все выполненные операции получаются из определения выражений в обратной польской записи.
Остается только доказать, что работа "*" корректна.
#### Корректность *
В обычной регулярке звездочка подразумевает объединение бесконечного числа 
произведений бесконечной степени(пример: (a + b)* = {пустое слово, a, b, aa, ab
ba, bb, aaa, aab, aba, и так далее). Однако хранить бесконечность мы не можем, поэтому 
мы будем искать всевозможные длины по данному модулю, которые можно получить из этой "*".
При помощи взятия наибольшего общего делителя всех элементов в сете, 
мы можем найти всевозможные длины по данному модулю(нод всех элементов в сете покажет минимальный порождающий элемент, благодаря 
которому мы уже получить всевозможные длины).